// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Interpreter;

  Interpreter = function() {
    this.playfield = null;
    this.pathSet = null;
    this.stats = {
      compileCalls: 0,
      jumpsPerformed: 0
    };
  };

  Interpreter.prototype._getPath = function(x, y, dir) {
    var currentChar, initialPath, loopingPath, path, pointer, splitPosition;
    path = new bef.Path();
    pointer = new bef.Pointer(x, y, dir, this.playfield.getSize());
    while (true) {
      currentChar = this.playfield.getAt(pointer.x, pointer.y);
      if (currentChar === '"') {
        path.push(pointer.x, pointer.y, pointer.dir, currentChar);
        while (true) {
          pointer.advance();
          currentChar = this.playfield.getAt(pointer.x, pointer.y);
          if (currentChar === '"') {
            path.push(pointer.x, pointer.y, pointer.dir, currentChar);
            break;
          }
          path.push(pointer.x, pointer.y, pointer.dir, currentChar, true);
        }
        pointer.advance();
        continue;
      }
      pointer.turn(currentChar);
      if (path.hasNonString(pointer.x, pointer.y, pointer.dir)) {
        splitPosition = (path.getEntryAt(pointer.x, pointer.y, pointer.dir)).index;
        if (splitPosition > 0) {
          initialPath = path.prefix(splitPosition);
          loopingPath = path.suffix(splitPosition);
          return [initialPath, loopingPath];
        } else {
          return [path];
        }
      }
      if (currentChar === '|' || currentChar === '_' || currentChar === '?' || currentChar === '@') {
        return [path];
      }
      path.push(pointer.x, pointer.y, pointer.dir, currentChar);
      if (currentChar === '#') {
        pointer.advance();
      }
      pointer.advance();
    }
  };

  Interpreter.prototype.put = function(x, y, e, currentX, currentY, currentDir, currentIndex) {
    var lastEntry, paths;
    if (!this.playfield.isInside(x, y)) {
      return;
    }
    paths = this.playfield.getPathsThrough(x, y);
    paths.forEach((function(_this) {
      return function(path) {
        _this.pathSet.remove(path);
        return _this.playfield.removePath(path);
      };
    })(this));
    this.playfield.setAt(x, y, e);
    lastEntry = this.currentPath.getLastEntryThrough(x, y);
    if ((lastEntry != null ? lastEntry.index : void 0) > currentIndex) {
      this.runtime.flags.pathInvalidatedAhead = true;
      return this.runtime.flags.exitPoint = {
        x: currentX,
        y: currentY,
        dir: currentDir
      };
    }
  };

  Interpreter.prototype.get = function(x, y) {
    var char;
    if (!this.playfield.isInside(x, y)) {
      return 0;
    }
    char = this.playfield.getAt(x, y);
    return char.charCodeAt(0);
  };

  Interpreter.prototype.execute = function(playfield, options, input) {
    var currentChar, exitPoint, newPaths, pathEndPoint, pointer;
    this.playfield = playfield;
    if (input == null) {
      input = [];
    }
    if (options == null) {
      options = {};
    }
    if (options.jumpLimit == null) {
      options.jumpLimit = -1;
    }
    if (options.compiler == null) {
      options.compiler = bef.BasicCompiler;
    }
    this.stats.compileCalls = 0;
    this.stats.jumpsPerformed = 0;
    this.pathSet = new bef.PathSet();
    this.runtime = new bef.Runtime(this);
    this.runtime.setInput(input);
    pointer = new bef.Pointer(0, 0, '>', this.playfield.getSize());
    while (true) {
      if (this.stats.jumpsPerformed === options.jumpLimit) {
        break;
      } else {
        this.stats.jumpsPerformed++;
      }
      this.currentPath = this.pathSet.getStartingFrom(pointer.x, pointer.y, pointer.dir);
      if (!this.currentPath) {
        newPaths = this._getPath(pointer.x, pointer.y, pointer.dir);
        newPaths.forEach((function(_this) {
          return function(newPath) {
            _this.stats.compileCalls++;
            options.compiler.compile(newPath);
            if (newPath.list.length) {
              _this.pathSet.add(newPath);
              return playfield.addPath(newPath);
            }
          };
        })(this));
      }
      if (this.currentPath == null) {
        this.currentPath = newPaths[0];
      }
      this.currentPath.body(this.runtime);
      if (this.runtime.flags.pathInvalidatedAhead) {
        this.runtime.flags.pathInvalidatedAhead = false;
        exitPoint = this.runtime.flags.exitPoint;
        pointer.set(exitPoint.x, exitPoint.y, exitPoint.dir);
        pointer.advance();
        continue;
      }
      if (this.currentPath.list.length) {
        pathEndPoint = this.currentPath.getEndPoint();
        pointer.set(pathEndPoint.x, pathEndPoint.y, pathEndPoint.dir);
        pointer.advance();
      }
      currentChar = this.playfield.getAt(pointer.x, pointer.y);
      if (currentChar === '|') {
        if (this.runtime.pop() === 0) {
          pointer.turn('v');
        } else {
          pointer.turn('^');
        }
        pointer.advance();
      } else if (currentChar === '_') {
        if (this.runtime.pop() === 0) {
          pointer.turn('>');
        } else {
          pointer.turn('<');
        }
        pointer.advance();
      } else if (currentChar === '?') {
        pointer.turn('^<v>'[Math.random() * 4 | 0]);
        pointer.advance();
      } else if (currentChar === '@') {
        break;
      } else {
        pointer.turn(currentChar);
      }
    }
  };

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.Interpreter = Interpreter;

}).call(this);
