// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';
  var EagerRuntime, S, canReach, findPath, getHash, getPointer, registerGraph;

  findPath = bef.PathFinder.findPath;

  S = bef.Symbols;

  EagerRuntime = function() {
    this.playfield = null;
    this.pathSet = null;
    this.stats = {
      compileCalls: 0,
      jumpsPerformed: 0
    };
  };

  canReach = function(graph, start, targets) {
    var traverse, visited;
    visited = new Set;
    traverse = function(start) {
      if (targets.has(start)) {
        return true;
      }
      if (visited.has(start)) {
        return false;
      }
      visited.add(start);
      return graph[start].some(function(arg) {
        var to;
        to = arg.to;
        return traverse(to);
      });
    };
    return traverse(start);
  };

  EagerRuntime.prototype.put = function(x, y, v, currentX, currentY, currentDir, from, to) {
    var i, len, path, paths, targets;
    if (!this.playfield.isInside(x, y)) {
      return;
    }
    paths = this.playfield.getPathsThrough(x, y);
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      this.pathSet.remove(path);
      this.playfield.removePath(path);
    }
    this.playfield.setAt(x, y, v);
    if (paths.length > 0) {
      targets = paths.reduce(function(targets, path) {
        targets.add(path.from);
        return targets;
      }, new Set);
      if (canReach(this.graph, to, targets)) {
        this.programState.flags.pathInvalidatedAhead = true;
        this.programState.flags.exitPoint = {
          x: currentX,
          y: currentY,
          dir: currentDir
        };
      }
    }
  };

  EagerRuntime.prototype.get = function(x, y) {
    if (this.playfield.isInside(x, y)) {
      return this.playfield.getAt(x, y);
    } else {
      return 0;
    }
  };

  getHash = function(pointer) {
    return pointer.x + "_" + pointer.y;
  };

  getPointer = function(point, space, dir) {
    var pointer;
    pointer = new bef.Pointer(point.x, point.y, dir, space);
    return pointer.advance();
  };

  EagerRuntime.prototype.buildGraph = function(start) {
    var buildEdge, dispatch, graph, hash;
    graph = {};
    dispatch = (function(_this) {
      return function(hash, destination) {
        var charCode, partial;
        charCode = _this.playfield.getAt(destination.x, destination.y);
        partial = getPointer.bind(null, destination, _this.playfield.getSize());
        switch (charCode) {
          case S.IFH:
            buildEdge(hash, partial(S.LEFT));
            buildEdge(hash, partial(S.RIGHT));
            break;
          case S.IFV:
            buildEdge(hash, partial(S.UP));
            buildEdge(hash, partial(S.DOWN));
            break;
          case S.RAND:
            buildEdge(hash, partial(S.UP));
            buildEdge(hash, partial(S.DOWN));
            buildEdge(hash, partial(S.LEFT));
            buildEdge(hash, partial(S.RIGHT));
            break;
          case S.PUT:
            buildEdge(hash, partial(destination.dir));
        }
      };
    })(this);
    buildEdge = (function(_this) {
      return function(hash, pointer) {
        var destination, newHash, newPath, ref, ref1, ref2, ref3;
        newPath = findPath(_this.playfield, pointer);
        if ((ref = newPath.path) != null) {
          ref.from = hash;
        }
        if ((ref1 = newPath.initialPath) != null) {
          ref1.from = hash;
        }
        if ((ref2 = newPath.loopingPath) != null) {
          ref2.from = hash;
        }
        if ((ref3 = newPath.path) != null) {
          ref3.to = getHash(newPath.path.getEndPoint());
        }
        if (newPath.type !== 'simple') {
          graph[hash].push({
            path: newPath,
            to: null
          });
        } else {
          destination = newPath.path.getAsList().length > 0 ? newPath.path.getEndPoint() : pointer;
          newHash = getHash(destination);
          graph[hash].push({
            path: newPath,
            to: newHash
          });
          if (graph[newHash] != null) {
            return;
          }
          graph[newHash] = [];
          dispatch(newHash, destination);
        }
      };
    })(this);
    hash = 'start';
    graph[hash] = [];
    buildEdge(hash, start);
    return graph;
  };

  EagerRuntime.prototype.compile = function(graph, options) {
    var assemble, assembleTight, edges, i, len, nodeName, ref, ref1;
    ref = options.compiler, assemble = ref.assemble, assembleTight = ref.assembleTight;
    ref1 = Object.keys(graph);
    for (i = 0, len = ref1.length; i < len; i++) {
      nodeName = ref1[i];
      edges = graph[nodeName];
      edges.forEach(function(edge) {
        var path, ref2, type;
        path = edge.path, (ref2 = edge.path, type = ref2.type);
        switch (type) {
          case 'composed':
            edge.assemble = function() {
              return (assemble(path.initialPath, options)) + "\nwhile (programState.isAlive()) {\n	" + (assemble(path.loopingPath, options)) + "\n}";
            };
            break;
          case 'looping':
            edge.assemble = function() {
              return "while (programState.isAlive()) {\n	" + (assemble(path.loopingPath, options)) + "\n}";
            };
            break;
          case 'simple':
            edge.assemble = function() {
              return assemble(path.path, options);
            };
            if (assembleTight != null) {
              edge.assembleTight = function() {
                return assembleTight(path.path, options);
              };
            }
        }
      });
    }
    this.code = bef.GraphCompiler.assemble({
      start: 'start',
      nodes: graph
    }, options);
    return new Function('programState', this.code);
  };

  registerGraph = function(graph, playfield, pathSet) {
    var edges, i, j, len, len1, nodeName, path, ref;
    playfield.clearPaths();
    pathSet.clear();
    ref = Object.keys(graph);
    for (i = 0, len = ref.length; i < len; i++) {
      nodeName = ref[i];
      edges = graph[nodeName];
      for (j = 0, len1 = edges.length; j < len1; j++) {
        path = edges[j].path;
        if (path.type === 'simple') {
          pathSet.add(path.path);
          playfield.addPath(path.path);
        } else if (path.type === 'looping') {
          pathSet.add(path.loopingPath);
          playfield.addPath(path.loopingPath);
        } else if (path.type === 'composed') {
          pathSet.add(path.loopingPath);
          pathSet.add(path.initialPath);
          playfield.addPath(path.loopingPath);
          playfield.addPath(path.initialPath);
        }
      }
    }
  };

  EagerRuntime.prototype.execute = function(playfield1, options, input) {
    var dir, program, ref, start, x, y;
    this.playfield = playfield1;
    if (input == null) {
      input = [];
    }
    if (options == null) {
      options = {};
    }
    if (options.jumpLimit == null) {
      options.jumpLimit = -1;
    }
    if (options.compiler == null) {
      options.compiler = bef.OptimizingCompiler;
    }
    if (options.fastConditionals == null) {
      options.fastConditionals = false;
    }
    this.stats.compileCalls = 0;
    this.stats.jumpsPerformed = 0;
    this.pathSet = new bef.PathSet();
    this.programState = new bef.ProgramState(this);
    this.programState.setInput(input);
    this.programState.maxChecks = options.jumpLimit;
    start = new bef.Pointer(0, 0, S.RIGHT, this.playfield.getSize());
    while (true) {
      this.stats.compileCalls++;
      this.graph = this.buildGraph(start);
      registerGraph(this.graph, this.playfield, this.pathSet);
      program = this.compile(this.graph, options);
      program(this.programState);
      if (this.programState.flags.pathInvalidatedAhead) {
        this.programState.flags.pathInvalidatedAhead = false;
        ref = this.programState.flags.exitPoint, x = ref.x, y = ref.y, dir = ref.dir;
        start.set(x, y, dir);
        start.advance();
      }
      if (this.programState.flags.exitRequest) {
        break;
      }
      this.stats.jumpsPerformed++;
      if (this.stats.jumpsPerformed > options.jumpLimit) {
        break;
      }
    }
  };

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.EagerRuntime = EagerRuntime;

}).call(this);
