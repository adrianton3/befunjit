// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var EagerRuntime, getHash, getPointer, registerGraph;

  EagerRuntime = function() {
    this.playfield = null;
    this.pathSet = null;
    this.stats = {
      compileCalls: 0,
      jumpsPerformed: 0
    };
  };

  EagerRuntime.prototype._getPath = function(x, y, dir) {
    var currentChar, initialPath, loopingPath, path, pointer, splitPosition;
    path = new bef.Path();
    pointer = new bef.Pointer(x, y, dir, this.playfield.getSize());
    while (true) {
      currentChar = this.playfield.getAt(pointer.x, pointer.y);
      if (currentChar === '"') {
        path.push(pointer.x, pointer.y, pointer.dir, currentChar);
        while (true) {
          pointer.advance();
          currentChar = this.playfield.getAt(pointer.x, pointer.y);
          if (currentChar === '"') {
            path.push(pointer.x, pointer.y, pointer.dir, currentChar);
            break;
          }
          path.push(pointer.x, pointer.y, pointer.dir, currentChar, true);
        }
        pointer.advance();
        continue;
      }
      pointer.turn(currentChar);
      if (path.hasNonString(pointer.x, pointer.y, pointer.dir)) {
        splitPosition = (path.getEntryAt(pointer.x, pointer.y, pointer.dir)).index;
        if (splitPosition > 0) {
          initialPath = path.prefix(splitPosition);
          loopingPath = path.suffix(splitPosition);
          return {
            type: 'composed',
            initialPath: initialPath,
            loopingPath: loopingPath
          };
        } else {
          return {
            type: 'looping',
            loopingPath: path
          };
        }
      }
      path.push(pointer.x, pointer.y, pointer.dir, currentChar);
      if (currentChar === '|' || currentChar === '_' || currentChar === '?' || currentChar === '@') {
        return {
          type: 'simple',
          path: path
        };
      }
      if (currentChar === '#') {
        pointer.advance();
      }
      pointer.advance();
    }
  };

  EagerRuntime.prototype.put = function(x, y, e, currentX, currentY, currentDir, currentIndex) {
    var paths;
    if (!this.playfield.isInside(x, y)) {
      return;
    }
    paths = this.playfield.getPathsThrough(x, y);
    paths.forEach((function(_this) {
      return function(path) {
        _this.pathSet.remove(path);
        return _this.playfield.removePath(path);
      };
    })(this));
    this.playfield.setAt(x, y, e);
    this.programState.flags.pathInvalidatedAhead = true;
    return this.programState.flags.exitPoint = {
      x: currentX,
      y: currentY,
      dir: currentDir
    };

    /*
    	lastEntry = @currentPath.getLastEntryThrough x, y
    	if lastEntry?.index > currentIndex
    		@programState.flags.pathInvalidatedAhead = true
    		@programState.flags.exitPoint =
    			x: currentX
    			y: currentY
    			dir: currentDir
     */
  };

  EagerRuntime.prototype.get = function(x, y) {
    var char;
    if (!this.playfield.isInside(x, y)) {
      return 0;
    }
    char = this.playfield.getAt(x, y);
    return char.charCodeAt(0);
  };

  getHash = function(pointer) {
    return "" + pointer.x + "_" + pointer.y;
  };

  getPointer = function(point, space, dir) {
    var pointer;
    pointer = new bef.Pointer(point.x, point.y, dir, space);
    return pointer.advance();
  };

  EagerRuntime.prototype.buildGraph = function(start) {
    var buildEdge, dispatch, graph, hash;
    graph = {};
    dispatch = (function(_this) {
      return function(hash, destination) {
        var currentChar, partial;
        currentChar = _this.playfield.getAt(destination.x, destination.y);
        partial = getPointer.bind(null, destination, _this.playfield.getSize());
        if (currentChar === '_') {
          buildEdge(hash, partial('<'));
          buildEdge(hash, partial('>'));
        } else if (currentChar === '|') {
          buildEdge(hash, partial('^'));
          buildEdge(hash, partial('v'));
        } else if (currentChar === '?') {
          buildEdge(hash, partial('^'));
          buildEdge(hash, partial('v'));
          buildEdge(hash, partial('<'));
          buildEdge(hash, partial('>'));
        } else if (currentChar === '@') {
          console.log('exit');
        } else {
          console.log("unknown char " + currentChar);
        }
      };
    })(this);
    buildEdge = (function(_this) {
      return function(hash, pointer) {
        var destination, newHash, newPath;
        newPath = _this._getPath(pointer.x, pointer.y, pointer.dir);
        if (newPath.type !== 'simple') {
          graph[hash].push({
            path: newPath,
            to: null
          });
        } else {
          destination = newPath.path.getAsList().length > 0 ? newPath.path.getEndPoint() : pointer;
          newHash = getHash(destination);
          graph[hash].push({
            path: newPath,
            to: newHash
          });
          if (graph[newHash] != null) {
            return;
          }
          graph[newHash] = [];
          dispatch(newHash, destination);
        }
      };
    })(this);
    hash = 'start';
    graph[hash] = [];
    buildEdge(hash, start);
    return graph;
  };

  EagerRuntime.prototype.compile = function(graph, options) {
    var assemble, code;
    assemble = options.compiler.assemble;
    (Object.keys(graph)).forEach(function(nodeName) {
      var edges;
      edges = graph[nodeName];
      return edges.forEach(function(edge) {
        var path, type, _ref;
        path = edge.path, (_ref = edge.path, type = _ref.type);
        return edge.code = (function() {
          switch (type) {
            case 'composed':
              return "" + (assemble(path.initialPath)) + "\nwhile (programState.isAlive()) {\n	" + (assemble(path.loopingPath)) + "\n}";
            case 'looping':
              return "while (programState.isAlive()) {\n	" + (assemble(path.loopingPath)) + "\n}";
            case 'simple':
              return assemble(path.path);
          }
        })();
      });
    });
    code = bef.GraphCompiler.assemble({
      start: 'start',
      nodes: graph
    });
    return new Function('programState', code);
  };

  registerGraph = function(graph, playfield, pathSet) {
    playfield.clearPaths();
    pathSet.clear();
    (Object.keys(graph)).forEach(function(node) {
      var edges;
      edges = graph[node];
      edges.forEach(function(_arg) {
        var path;
        path = _arg.path;
        if (path.type === 'simple') {
          pathSet.add(path.path);
          playfield.addPath(path.path);
        } else if (path.type === 'looping') {
          pathSet.add(path.loopingPath);
          playfield.addPath(path.loopingPath);
        } else if (path.type === 'composed') {
          pathSet.add(path.loopingPath);
          pathSet.add(path.initialPath);
          playfield.addPath(path.loopingPath);
          playfield.addPath(path.initialPath);
        }
      });
    });
  };

  EagerRuntime.prototype.execute = function(playfield, options, input) {
    var dir, graph, program, start, x, y, _ref;
    this.playfield = playfield;
    if (input == null) {
      input = [];
    }
    if (options == null) {
      options = {};
    }
    if (options.jumpLimit == null) {
      options.jumpLimit = -1;
    }
    if (options.compiler == null) {
      options.compiler = bef.OptimizingCompiler;
    }
    this.stats.compileCalls = 0;
    this.stats.jumpsPerformed = 0;
    this.pathSet = new bef.PathSet();
    this.programState = new bef.ProgramState(this);
    this.programState.setInput(input);
    start = new bef.Pointer(0, 0, '>', this.playfield.getSize());
    while (true) {
      this.stats.compileCalls++;
      graph = this.buildGraph(start);
      registerGraph(graph, this.playfield, this.pathSet);
      program = this.compile(graph, options);
      program(this.programState);
      if (this.programState.flags.pathInvalidatedAhead) {
        this.programState.flags.pathInvalidatedAhead = false;
        _ref = this.programState.flags.exitPoint, x = _ref.x, y = _ref.y, dir = _ref.dir;
        start.set(x, y, dir);
        start.advance();
      }
      if (this.programState.flags.exitRequest) {
        break;
      }
      this.stats.jumpsPerformed++;
      if (this.stats.jumpsPerformed > options.jumpLimit) {
        break;
      }
    }
  };

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.EagerRuntime = EagerRuntime;

}).call(this);
