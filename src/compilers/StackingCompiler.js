// Generated by CoffeeScript 1.12.4
(function() {
  'use strict';
  var StackingCompiler, assemble, assembleTight, binaryOperator, codeMap, digitPusher, getDepth, isNumber, makeStack, writeBack;

  getDepth = bef.PathMetrics.getDepth;

  isNumber = function(obj) {
    return typeof obj === 'number';
  };

  digitPusher = function(digit) {
    return function(stack) {
      stack.push(digit);
    };
  };

  binaryOperator = function(operatorFunction, operatorChar, stringFunction) {
    return function(stack) {
      var fun, operand1, operand2;
      operand1 = stack.pop();
      operand2 = stack.pop();
      fun = (isNumber(operand1)) && (isNumber(operand2)) ? operatorFunction : stringFunction;
      stack.push(fun(operand1, operand2));
    };
  };

  codeMap = new Map([
    [' ', function() {}], ['0', digitPusher(0)], ['1', digitPusher(1)], ['2', digitPusher(2)], ['3', digitPusher(3)], ['4', digitPusher(4)], ['5', digitPusher(5)], ['6', digitPusher(6)], ['7', digitPusher(7)], ['8', digitPusher(8)], ['9', digitPusher(9)], [
      '+', binaryOperator((function(o1, o2) {
        return o2 + o1;
      }), '+', function(o1, o2) {
        return "(" + o2 + " + " + o1 + ")";
      })
    ], [
      '-', binaryOperator((function(o1, o2) {
        return o2 - o1;
      }), '-', function(o1, o2) {
        return "(" + o2 + " - " + o1 + ")";
      })
    ], [
      '*', binaryOperator((function(o1, o2) {
        return o2 * o1;
      }), '*', function(o1, o2) {
        return "(" + o2 + " * " + o1 + ")";
      })
    ], [
      '/', binaryOperator((function(o1, o2) {
        return Math.floor(o2 / o1);
      }), '/', function(o1, o2) {
        return "Math.floor(" + o2 + " / " + o1 + ")";
      })
    ], [
      '%', binaryOperator((function(o1, o2) {
        return o2 % o1;
      }), '%', function(o1, o2) {
        return "(" + o2 + " % " + o1 + ")";
      })
    ], [
      '!', function(stack) {
        var operand;
        operand = stack.pop();
        stack.push(isNumber(operand) ? +(!operand) : "(+!" + operand + ")");
      }
    ], [
      '`', binaryOperator((function(o1, o2) {
        return +(o1 < o2);
      }), '`', function(o1, o2) {
        return "(+(" + o1 + " < " + o2 + "))";
      })
    ], ['^', function() {}], ['<', function() {}], ['v', function() {}], ['>', function() {}], ['?', function() {}], ['_', function() {}], ['|', function() {}], ['"', function() {}], [
      ':', function(stack) {
        var top;
        top = stack.peek();
        stack.push(top);
      }
    ], [
      '\\', function(stack) {
        var e1, e2;
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e1, e2);
      }
    ], [
      '$', function(stack) {
        stack.pop();
      }
    ], [
      '.', function(stack) {
        stack.out("programState.out(" + (stack.pop()) + ")");
      }
    ], [
      ',', function(stack) {
        stack.out("programState.out(String.fromCharCode(" + (stack.pop()) + "))");
      }
    ], ['#', function() {}], [
      'p', function() {
        return '';
      }
    ], [
      'g', function(stack) {
        stack.push("programState.get(" + (stack.pop()) + ", " + (stack.pop()) + ")");
      }
    ], [
      '&', function(stack) {
        stack.push(stack.next());
      }
    ], [
      '~', function(stack) {
        stack.push(stack.nextChar());
      }
    ], [
      '@', function(stack) {
        stack.exit();
      }
    ]
  ]);

  makeStack = function(uid, ending, options) {
    var declarations, exitRequest, freePops, makeNext, popCount, popMethod, pushBack, pushCount, reads, ref, ref1, ref2, ref3, stack, stackObj, writes;
    if (options == null) {
      options = {};
    }
    popMethod = (ref = options.popMethod) != null ? ref : 'pop';
    freePops = (ref1 = options.freePops) != null ? ref1 : 2e308;
    popCount = (ref2 = options.popCount) != null ? ref2 : 0;
    pushCount = (ref3 = options.pushCount) != null ? ref3 : 0;
    stack = [];
    declarations = [];
    reads = [];
    writes = [];
    exitRequest = false;
    stackObj = {};
    stackObj.push = function() {
      Array.prototype.push.apply(stack, arguments);
    };
    stackObj.pop = function() {
      var name;
      if (stack.length > 0) {
        return stack.pop();
      } else if (freePops <= 0) {
        return 0;
      } else {
        freePops--;
        name = "p" + uid + "_" + declarations.length;
        declarations.push(popCount > 0 ? "var " + name + " = t" + uid + "_" + (popCount - 1) : "var " + name + " = programState." + popMethod + "()");
        popCount = Math.max(0, popCount - 1);
        return name;
      }
    };
    stackObj.peek = function() {
      var name;
      if (stack.length > 0) {
        return stack[stack.length - 1];
      } else {
        name = "p" + uid + "_" + declarations.length;
        declarations.push(popCount > 0 ? "var " + name + " = t" + uid + "_" + (popCount - 1) : "var " + name + " = programState.peek()");
        return name;
      }
    };
    makeNext = function(methodName) {
      return function() {
        var name;
        name = "r" + uid + "_" + reads.length;
        reads.push("var " + name + " = programState." + methodName + "()");
        return name;
      };
    };
    stackObj.next = makeNext('next');
    stackObj.nextChar = makeNext('nextChar');
    stackObj.out = function(entry) {
      writes.push(entry);
    };
    pushBack = function(stack, pushCount) {
      var copies, i, pushes;
      copies = (function() {
        var j, ref4, results;
        results = [];
        for (i = j = 0, ref4 = pushCount; 0 <= ref4 ? j < ref4 : j > ref4; i = 0 <= ref4 ? ++j : --j) {
          results.push("t" + uid + "_" + i + " = " + stack[i]);
        }
        return results;
      })();
      if (pushCount < stack.length) {
        pushes = stack.slice(pushCount);
        return (copies.join('\n')) + "\nstack.push(" + (pushes.join(', ')) + ")";
      } else {
        return copies.join('\n');
      }
    };
    stackObj.stringify = function() {
      var last, ref4, stackChunk;
      stackChunk = (ref4 = ending != null ? ending.char : void 0) === '|' || ref4 === '_' ? stack.length === 0 ? "branchFlag = " + (this.pop()) + ";" : stack.length === 1 ? "branchFlag = " + stack[0] + ";" : (last = stack.pop(), (pushBack(stack, pushCount)) + "\nbranchFlag = " + last) : stack.length === 0 ? '' : pushBack(stack, pushCount);
      return (declarations.join('\n')) + "\n" + (reads.join('\n')) + "\n" + stackChunk + "\n" + (writes.join('\n')) + "\n" + (exitRequest ? 'programState.exit()' : '');
    };
    stackObj.exit = function() {
      return exitRequest = true;
    };
    return stackObj;
  };

  assemble = function(path, options) {
    var charList, codeGenerator, entry, j, len, stack;
    charList = path.getAsList();
    stack = makeStack(path.id, path.ending, options);
    for (j = 0, len = charList.length; j < len; j++) {
      entry = charList[j];
      if (entry.string) {
        stack.push(entry.char.charCodeAt(0));
      } else {
        codeGenerator = codeMap.get(entry.char);
        if (codeGenerator != null) {
          codeGenerator(stack);
        }
      }
    }
    return stack.stringify();
  };

  writeBack = function(count, uid) {
    var i, temps;
    temps = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push("t" + uid + "_" + i);
      }
      return results;
    })();
    return "stack.push(" + (temps.join(', ')) + ")";
  };

  assembleTight = function(path, options) {
    var max, popCount, pushCount, ref, sum, tempCount;
    ref = getDepth(path), max = ref.max, sum = ref.sum;
    tempCount = Math.min(max, max + sum);
    if (tempCount <= 0) {
      return assemble(path, options);
    } else {
      pushCount = tempCount;
      popCount = tempCount;
      return {
        pre: assemble(path, Object.assign({
          pushCount: pushCount
        }, options)),
        body: assemble(path, Object.assign({
          popCount: popCount,
          pushCount: pushCount
        }, options)),
        post: writeBack(tempCount, path.id)
      };
    }
  };

  StackingCompiler = function() {};

  Object.assign(StackingCompiler, {
    codeMap: codeMap,
    makeStack: makeStack,
    assemble: assemble,
    assembleTight: assembleTight
  });

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.StackingCompiler = StackingCompiler;

}).call(this);
