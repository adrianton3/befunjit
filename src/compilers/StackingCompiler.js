// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var StackingCompiler, assemble, binaryOperator, codeMap, compile, digitPusher, isNumber, makeStack;

  isNumber = function(obj) {
    return typeof obj === 'number';
  };

  digitPusher = function(digit) {
    return function(x, y, dir, index, stack) {
      stack.push(digit);
    };
  };

  binaryOperator = function(operatorFunction, operatorChar, stringFunction) {
    return function(x, y, dir, index, stack) {
      var fun, operand1, operand2;
      operand1 = stack.pop();
      operand2 = stack.pop();
      fun = (isNumber(operand1)) && (isNumber(operand2)) ? operatorFunction : stringFunction;
      stack.push(fun(operand1, operand2));
    };
  };

  codeMap = {
    ' ': function() {},
    '0': digitPusher(0),
    '1': digitPusher(1),
    '2': digitPusher(2),
    '3': digitPusher(3),
    '4': digitPusher(4),
    '5': digitPusher(5),
    '6': digitPusher(6),
    '7': digitPusher(7),
    '8': digitPusher(8),
    '9': digitPusher(9),
    '+': binaryOperator((function(o1, o2) {
      return o2 + o1;
    }), '+', function(o1, o2) {
      return "(" + o2 + " + " + o1 + ")";
    }),
    '-': binaryOperator((function(o1, o2) {
      return o2 - o1;
    }), '-', function(o1, o2) {
      return "(" + o2 + " - " + o1 + ")";
    }),
    '*': binaryOperator((function(o1, o2) {
      return o2 * o1;
    }), '*', function(o1, o2) {
      return "(" + o2 + " * " + o1 + ")";
    }),
    '/': binaryOperator((function(o1, o2) {
      return Math.floor(o2 / o1);
    }), '/', function(o1, o2) {
      return "Math.floor(" + o2 + " / " + o1 + ")";
    }),
    '%': binaryOperator((function(o1, o2) {
      return o2 % o1;
    }), '%', function(o1, o2) {
      return "(" + o2 + " % " + o1 + ")";
    }),
    '!': function(x, y, dir, index, stack) {
      var operand;
      operand = stack.pop();
      stack.push(isNumber(operand) ? +(!operand) : "(+!" + operand + ")");
    },
    '`': binaryOperator((function(o1, o2) {
      return +(o1 < o2);
    }), '`', function(o1, o2) {
      return "(+(" + o1 + " < " + o2 + "))";
    }),
    '^': function() {},
    '<': function() {},
    'v': function() {},
    '>': function() {},
    '?': function() {},
    '_': function() {},
    '|': function() {},
    '"': function() {},
    ':': function(x, y, dir, index, stack) {
      var top;
      top = stack.peek();
      stack.push(top);
    },
    '\\': function(x, y, dir, index, stack) {
      var e1, e2;
      e1 = stack.pop();
      e2 = stack.pop();
      stack.push(e1, e2);
    },
    '$': function(x, y, dir, index, stack) {
      stack.pop();
    },
    '.': function(x, y, dir, index, stack) {
      stack.out("programState.out(" + (stack.pop()) + ")");
    },
    ',': function(x, y, dir, index, stack) {
      stack.out("programState.out(String.fromCharCode(" + (stack.pop()) + "))");
    },
    '#': function() {},
    'p': function(x, y, dir, index, stack, from, to) {
      var p1, p2, p3;
      p1 = stack.pop();
      p2 = stack.pop();
      p3 = stack.pop();
      stack.dump();
      stack.pushChunk("programState.put(\n	" + p1 + ",\n	" + p2 + ",\n	" + p3 + ",\n	" + x + ", " + y + ", '" + dir + "', " + index + ",\n	'" + from + "', '" + to + "'\n)\nif (programState.flags.pathInvalidatedAhead) {\n	return\n}");
    },
    'g': function(x, y, dir, index, stack) {
      stack.push("programState.get(" + (stack.pop()) + ", " + (stack.pop()) + ")");
    },
    '&': function(x, y, dir, index, stack) {
      stack.push(stack.next());
    },
    '~': function(x, y, dir, index, stack) {
      stack.push(stack.nextChar());
    },
    '@': function(x, y, dir, index, stack) {
      stack.exit();
    }
  };

  makeStack = function(uid, options) {
    var chunks, declarations, exitRequest, fastConditionals, freePops, makeNext, popMethod, reads, ref, ref1, ref2, stack, stackObj, writes;
    if (options == null) {
      options = {};
    }
    popMethod = (ref = options.popMethod) != null ? ref : 'pop';
    freePops = (ref1 = options.freePops) != null ? ref1 : Infinity;
    fastConditionals = (ref2 = options.fastConditionals) != null ? ref2 : false;
    stack = [];
    declarations = [];
    reads = [];
    writes = [];
    chunks = [];
    exitRequest = false;
    stackObj = {};
    stackObj.push = function() {
      Array.prototype.push.apply(stack, arguments);
    };
    stackObj.pop = function() {
      var name;
      if (stack.length > 0) {
        return stack.pop();
      } else if (freePops <= 0) {
        return 0;
      } else {
        freePops--;
        name = "p" + uid + "_" + declarations.length;
        declarations.push("var " + name + " = programState." + popMethod + "()");
        return name;
      }
    };
    stackObj.peek = function() {
      var name;
      if (stack.length > 0) {
        return stack[stack.length - 1];
      } else {
        name = "p" + uid + "_" + declarations.length;
        declarations.push("var " + name + " = programState.peek()");
        return name;
      }
    };
    makeNext = function(methodName) {
      return function() {
        var name;
        name = "r" + uid + "_" + reads.length;
        reads.push("var " + name + " = programState." + methodName + "()");
        return name;
      };
    };
    stackObj.next = makeNext('next');
    stackObj.nextChar = makeNext('nextChar');
    stackObj.out = function(entry) {
      writes.push(entry);
    };
    stackObj.dump = function() {
      var branchChunk, stackChunk;
      stackChunk = fastConditionals ? stack.length === 0 ? 'branchFlag = programState.pop();' : stack.length === 1 ? "branchFlag = " + stack[0] + ";" : (branchChunk = "branchFlag = " + stack[stack.length - 1] + ";", stack.pop(), "programState.push(" + (stack.join(', ')) + ");\n" + branchChunk) : stack.length === 0 ? '' : "programState.push(" + (stack.join(', ')) + ");";
      chunks.push((declarations.join('\n')) + "\n" + (reads.join('\n')) + "\n" + stackChunk + "\n" + (writes.join('\n')));
      stack = [];
      declarations = [];
      reads = [];
      writes = [];
    };
    stackObj.pushChunk = function(entry) {
      chunks.push(entry);
    };
    stackObj.stringify = function() {
      return (chunks.join('\n')) + "\n" + (exitRequest ? 'programState.exit()' : '');
    };
    stackObj.exit = function() {
      return exitRequest = true;
    };
    return stackObj;
  };

  assemble = function(path, options) {
    var charList, stack;
    charList = path.getAsList();
    stack = makeStack(path.id, options);
    charList.forEach(function(entry, i) {
      var codeGenerator;
      if (entry.string) {
        stack.push(entry.char.charCodeAt(0));
      } else {
        codeGenerator = codeMap[entry.char];
        if (codeGenerator != null) {
          codeGenerator(entry.x, entry.y, entry.dir, i, stack, path.from, path.to);
        }
      }
    });
    stack.dump();
    return stack.stringify();
  };

  compile = function(path, options) {
    var code, compiled;
    code = assemble(path, options);
    path.code = code;
    compiled = new Function('programState', code);
    return path.body = compiled;
  };

  StackingCompiler = function() {};

  Object.assign(StackingCompiler, {
    codeMap: codeMap,
    makeStack: makeStack,
    assemble: assemble,
    compile: compile
  });

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.StackingCompiler = StackingCompiler;

}).call(this);
