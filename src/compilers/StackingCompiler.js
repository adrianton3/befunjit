// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';
  var S, StackingCompiler, assemble, assembleTight, binaryOperator, codeMap, digitPusher, getDepth, isNumber, makeStack, writeBack;

  getDepth = bef.PathMetrics.getDepth;

  S = bef.Symbols;

  isNumber = function(obj) {
    return typeof obj === 'number';
  };

  digitPusher = function(digit) {
    return function(stack) {
      stack.push(digit);
    };
  };

  binaryOperator = function(operatorFunction, operatorChar, stringFunction) {
    return function(stack) {
      var fun, operand1, operand2;
      operand1 = stack.pop();
      operand2 = stack.pop();
      fun = (isNumber(operand1)) && (isNumber(operand2)) ? operatorFunction : stringFunction;
      stack.push(fun(operand1, operand2));
    };
  };

  codeMap = new Map([
    [S.BLANK, function() {}], [S.D0, digitPusher(0)], [S.D1, digitPusher(1)], [S.D2, digitPusher(2)], [S.D3, digitPusher(3)], [S.D4, digitPusher(4)], [S.D5, digitPusher(5)], [S.D6, digitPusher(6)], [S.D7, digitPusher(7)], [S.D8, digitPusher(8)], [S.D9, digitPusher(9)], [
      S.ADD, binaryOperator((function(o1, o2) {
        return o2 + o1;
      }), '+', function(o1, o2) {
        return "(" + o2 + " + " + o1 + ")";
      })
    ], [
      S.SUB, binaryOperator((function(o1, o2) {
        return o2 - o1;
      }), '-', function(o1, o2) {
        return "(" + o2 + " - " + o1 + ")";
      })
    ], [
      S.MUL, binaryOperator((function(o1, o2) {
        return o2 * o1;
      }), '*', function(o1, o2) {
        return "(" + o2 + " * " + o1 + ")";
      })
    ], [
      S.DIV, binaryOperator((function(o1, o2) {
        return Math.floor(o2 / o1);
      }), '/', function(o1, o2) {
        return "Math.floor(" + o2 + " / " + o1 + ")";
      })
    ], [
      S.MOD, binaryOperator((function(o1, o2) {
        return o2 % o1;
      }), '%', function(o1, o2) {
        return "(" + o2 + " % " + o1 + ")";
      })
    ], [
      S.NOT, function(stack) {
        var operand;
        operand = stack.pop();
        stack.push(isNumber(operand) ? +(!operand) : "(+!" + operand + ")");
      }
    ], [
      S.GT, binaryOperator((function(o1, o2) {
        return +(o1 < o2);
      }), '`', function(o1, o2) {
        return "(+(" + o1 + " < " + o2 + "))";
      })
    ], [S.UP, function() {}], [S.LEFT, function() {}], [S.DOWN, function() {}], [S.RIGHT, function() {}], [S.RAND, function() {}], [S.IFH, function() {}], [S.IFV, function() {}], [S.QUOT, function() {}], [
      S.DUP, function(stack) {
        var top;
        top = stack.peek();
        stack.push(top);
      }
    ], [
      S.SWAP, function(stack) {
        var e1, e2;
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e1, e2);
      }
    ], [
      S.DROP, function(stack) {
        stack.pop();
      }
    ], [
      S.OUTI, function(stack) {
        stack.out("programState.out(" + (stack.pop()) + ")");
      }
    ], [
      S.OUTC, function(stack) {
        stack.out("programState.outChar(String.fromCharCode(" + (stack.pop()) + "))");
      }
    ], [S.JUMP, function() {}], [
      S.PUT, function() {
        return '';
      }
    ], [
      S.GET, function(stack) {
        stack.push("programState.get(" + (stack.pop()) + ", " + (stack.pop()) + ")");
      }
    ], [
      S.INI, function(stack) {
        stack.push(stack.next());
      }
    ], [
      S.INC, function(stack) {
        stack.push(stack.nextChar());
      }
    ], [
      S.END, function(stack) {
        stack.exit();
      }
    ]
  ]);

  makeStack = function(uid, ending, options) {
    var declarations, exitRequest, freePops, makeNext, popCount, popMethod, pushBack, pushCount, reads, ref, ref1, ref2, ref3, stack, stackObj, writes;
    if (options == null) {
      options = {};
    }
    popMethod = (ref = options.popMethod) != null ? ref : 'pop';
    freePops = (ref1 = options.freePops) != null ? ref1 : 2e308;
    popCount = (ref2 = options.popCount) != null ? ref2 : 0;
    pushCount = (ref3 = options.pushCount) != null ? ref3 : 0;
    stack = [];
    declarations = [];
    reads = [];
    writes = [];
    exitRequest = false;
    stackObj = {};
    stackObj.push = function() {
      Array.prototype.push.apply(stack, arguments);
    };
    stackObj.pop = function() {
      var name;
      if (stack.length > 0) {
        return stack.pop();
      } else if (freePops <= 0) {
        return 0;
      } else {
        freePops--;
        name = "p" + uid + "_" + declarations.length;
        declarations.push(popCount > 0 ? "var " + name + " = t" + uid + "_" + (popCount - 1) : "var " + name + " = programState." + popMethod + "()");
        popCount = Math.max(0, popCount - 1);
        return name;
      }
    };
    stackObj.peek = function() {
      var name;
      if (stack.length > 0) {
        return stack[stack.length - 1];
      } else {
        name = "p" + uid + "_" + declarations.length;
        declarations.push(popCount > 0 ? "var " + name + " = t" + uid + "_" + (popCount - 1) : "var " + name + " = programState.peek()");
        return name;
      }
    };
    makeNext = function(methodName) {
      return function() {
        var name;
        name = "r" + uid + "_" + reads.length;
        reads.push("var " + name + " = programState." + methodName + "()");
        return name;
      };
    };
    stackObj.next = makeNext('next');
    stackObj.nextChar = makeNext('nextChar');
    stackObj.out = function(entry) {
      writes.push(entry);
    };
    pushBack = function(stack, pushCount) {
      var copies, i, pushes;
      copies = (function() {
        var j, ref4, results;
        results = [];
        for (i = j = 0, ref4 = pushCount; 0 <= ref4 ? j < ref4 : j > ref4; i = 0 <= ref4 ? ++j : --j) {
          results.push("t" + uid + "_" + i + " = " + stack[i]);
        }
        return results;
      })();
      if (pushCount < stack.length) {
        pushes = stack.slice(pushCount);
        return (copies.join('\n')) + "\nstack.push(" + (pushes.join(', ')) + ")";
      } else {
        return copies.join('\n');
      }
    };
    stackObj.stringify = function() {
      var last, ref4, stackChunk;
      stackChunk = (ref4 = ending != null ? ending.charCode : void 0) === 124 || ref4 === 95 ? stack.length === 0 ? "branchFlag = " + (this.pop()) + ";" : stack.length === 1 ? "branchFlag = " + stack[0] + ";" : (last = stack.pop(), (pushBack(stack, pushCount)) + "\nbranchFlag = " + last) : stack.length === 0 ? '' : pushBack(stack, pushCount);
      return (declarations.join('\n')) + "\n" + (reads.join('\n')) + "\n" + stackChunk + "\n" + (writes.join('\n')) + "\n" + (exitRequest ? 'programState.exit()' : '');
    };
    stackObj.exit = function() {
      return exitRequest = true;
    };
    return stackObj;
  };

  assemble = function(path, options) {
    var charList, codeGenerator, entry, j, len, stack;
    charList = path.getAsList();
    stack = makeStack(path.id, path.ending, options);
    for (j = 0, len = charList.length; j < len; j++) {
      entry = charList[j];
      if (entry.string) {
        stack.push(entry.charCode);
      } else {
        codeGenerator = codeMap.get(entry.charCode);
        if (codeGenerator != null) {
          codeGenerator(stack);
        }
      }
    }
    return stack.stringify();
  };

  writeBack = function(count, uid) {
    var i, temps;
    temps = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push("t" + uid + "_" + i);
      }
      return results;
    })();
    return "stack.push(" + (temps.join(', ')) + ")";
  };

  assembleTight = function(path, options) {
    var max, popCount, pushCount, ref, sum, tempCount;
    ref = getDepth(path), max = ref.max, sum = ref.sum;
    tempCount = Math.min(max, max + sum);
    if (tempCount <= 0) {
      return assemble(path, options);
    } else {
      pushCount = tempCount;
      popCount = tempCount;
      return {
        pre: assemble(path, Object.assign({
          pushCount: pushCount
        }, options)),
        body: assemble(path, Object.assign({
          popCount: popCount,
          pushCount: pushCount
        }, options)),
        post: writeBack(tempCount, path.id)
      };
    }
  };

  StackingCompiler = function() {};

  Object.assign(StackingCompiler, {
    codeMap: codeMap,
    makeStack: makeStack,
    assemble: assemble,
    assembleTight: assembleTight
  });

  if (window.bef == null) {
    window.bef = {};
  }

  window.bef.StackingCompiler = StackingCompiler;

}).call(this);
